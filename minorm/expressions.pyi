from typing import Any, Optional, Tuple

LOOKUP_SEPARATOR: str

class WhereCondition:
    AND: str = ...
    OR: str = ...
    NOT: str = ...
    EQ: str = ...
    IN: str = ...
    LIKE: str = ...
    LOOKUP_MAPPING: Tuple[Tuple[str, str]] = ...
    LIKE_PATTERNS: Tuple[Tuple[str, str]] = ...
    MULTIPLE_VALUE_OPS: Tuple[str] = ...
    field: str = ...
    op: str = ...
    value: Any = ...
    no_escape: bool = ...
    _and: Optional['WhereCondition'] = ...
    _or: Optional['WhereCondition'] = ...
    _negated: bool = ...
    def __init__(self, field: str, op: str, value: Any, no_escape: bool = ...) -> None: ...
    def __str__(self): ...
    def values(self) -> Tuple[Any]: ...
    @property
    def resolved_escape(self) -> str: ...
    def __and__(self, other: 'WhereCondition'): ...
    def __or__(self, other: 'WhereCondition'): ...
    def __invert__(self): ...
    @classmethod
    def resolve_lookup(cls, lookup_key: str): ...
    @classmethod
    def for_lookup(cls, field_name: str, lookup: str, value: Any): ...
    def clone(self) -> 'WhereCondition': ...

class OrderByExpression:
    ASC: str = ...
    DESC: str = ...
    value: str = ...
    ordering: str = ...
    def __init__(self, value: str, ordering: str) -> None: ...
    @classmethod
    def from_field_name(cls, field_name: str): ...
    def __str__(self): ...
    def __eq__(self, other: object) -> bool: ...

class JoinExpression:
    LEFT_OUTER: str = ...
    INNER: str = ...
    table_name: str = ...
    on: WhereCondition = ...
    join_type: str = ...
    def __init__(self, table_name: str, on: WhereCondition, join_type: str = ...) -> None: ...
    def __str__(self): ...
    @classmethod
    def on_pk(cls, outer_table: str, pk_field: str, fk_field: str, join_type: Optional[str] = ...): ...
