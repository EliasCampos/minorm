from typing import Any, Callable, Dict, Iterator, List, NamedTuple, Optional, Sequence, Type, Tuple, Union

from minorm.expressions import JoinExpression as JoinExpression, OrderByExpression, WhereCondition
from minorm.models import Model
from minorm.queries import SelectQuery


class QuerySet:
    model: Type[Model] = ...
    _where: Optional[WhereCondition] = ...
    _order_by: List[OrderByExpression] = ...
    _limit: Optional[int] = ...
    _related: RelationNode = ...
    _values_mapping: Dict = ...
    def __init__(self, model: Type[Model]) -> None: ...
    def all(self) -> 'QuerySet': ...
    def filter(self, **kwargs: Any) -> 'QuerySet': ...
    def aswell(self, **kwargs: Any) -> 'QuerySet': ...
    def order_by(self, *args: str) -> 'QuerySet': ...
    def values(self, *args: Optional[str]) -> 'QuerySet': ...
    def select_related(self, *args: Optional[str]) -> 'QuerySet': ...
    def fetch(self) -> List[Any]: ...
    def update(self, **kwargs: Any) -> int: ...
    def delete(self) -> int: ...
    def create(self, **kwargs: Any) -> Model: ...
    def get(self, **kwargs: Any) -> Union[Model, Dict[str, Any]]: ...
    def first(self) -> Optional[Union[Model, Dict[str, Any]]]: ...
    def exists(self) -> bool: ...
    def __iter__(self) -> Iterator: ...
    def __getitem__(self, item: Union[int, slice]) -> Union['QuerySet', Model, Dict[str, Any]]: ...
    def bulk_create(self, instances: Sequence[Model]) -> int: ...
    @property
    def query(self) -> SelectQuery: ...
    @property
    def query_params(self) -> Tuple[Any]: ...
    def _clone(self) -> 'QuerySet': ...
    def _where_action(self, *args: WhereCondition, **kwargs: Any) -> WhereCondition: ...
    def _reset_where(self, where_cond: WhereCondition, op: Callable) -> None: ...
    def _fetch_all(self, **extra_lookups: Any) -> List[Tuple[Any]]: ...
    def _fetch_one(self, **extra_lookups: Any) -> Tuple[Any]: ...
    def _prepare_sql(self, **extra_lookups: Any) -> Tuple[str, Tuple[Any]]: ...
    def _check_pk_lookups(self, kwargs: Dict[str, Any]) -> Dict[str, Any]: ...
    def _instance_from_row(self, row: Tuple[Any], is_namedtuple: bool = ...): ...

class RelationNode:
    model: Type[Model] = ...
    depth: int = ...
    position: int = ...
    is_selected: bool = ...
    relations: Dict[str, 'RelationNode'] = ...
    def __init__(self, base_model: Type[Model], depth: int = ..., position: int = ...) -> None: ...
    def resolve_relation(self, lookup_parts: List[str], is_selected: bool = ...): ...
    @property
    def is_root_node(self) -> bool: ...
    @property
    def table_shortcut(self) -> str: ...
    @property
    def table_name(self) -> str: ...
    def get_column_names(self) -> List[str]: ...
    def get_joins(self) -> List[JoinExpression]: ...
    def row_to_instance(self, row: Tuple[Any], is_namedtuple: bool, row_shift: int = ...) -> Tuple[Model, int]: ...
    def clone(self) -> 'RelationNode': ...
